### 멀티캠퍼스 인공지능 자연어처리[NLP]기반 기업 데이터 분석.
- 2주차 1일 (5/17)
---
> #### 1. NUMPY
>> Numerical Python : 행열 연산이나 다차원 배열을 편리하게 처리
>>
>> 배열 단위로 벡터, 행렬 연산등을 파이썬의 기본 리스트에 비해 빠르고 적은양의 메모리로 연산.
>> 
>> 선형대수, 통계관련 빌트인 함수 내장
>> 
>> 브로드캐스트 지원 - 형태(차원)가 다른 행렬끼리의 계산
>>
>> #### NUMPY 사용하는 이유
>>> ```Python
>>> matrix_1 = [[1,2],[3,4]]
>>> matrix_2 = [[5,6],[7,8]]
>>> 
>>> # 행렬합 구하기
>>> matrix_result = np.array(matrix_1) + np.array(matrix_2)
>>>
>>> # matrix_1에 숫자 1씩 더하기
>>> matrix_1 = np.array(matrix_1) + 1
>>> ```
>> 리스트 연산에 비해 넘파이가 더 빠르기도 하다.
>> 
>> #### NUMPY 자료형
>> 
>> int(8bit, 16bit, 32bit, 64bit)
>> - 부호가 있음, 비트수 만큼 크기를 가지는 정수형
>> 
>> ㅕint(8bit, 16bit, 32bit, 64bit)
>> - 부호가 없음, 비트수 만큼 크기를 가지는 정수형
>> 
>> float(8bit, 16bit, 32bit, 64bit, 128bit)
>> - 부호가 있음, 비트수 만큼 크기를 가지는 실수형
>> 
>> 복소수형
>> - complex64 : 두개의 32비트 부동소수점으로 표시되는 복소수
>> 
>> - complex128 : 두개의 64비트 부동소수점으로 표시되는 복소수
>> 
>> bool : True, False
>> 
>> #### ndarray
>> 넘파이 리스트 ndarray만들기
>> - np.array(데이터)
>>> ```Python
>>> x = np.array([1, 2, 3, 4])
>>> print(x.dtype) #int64
>>> ```
>> - np.float32(데이터)
>>> ```Python
>>> x = np.float32([1, 2, 3, 4])
>>> print(x.dtype) #float32
>>> ```
>> - np.int(데이터)
>>> ```Python
>>> x = np.uint(32)
>>> print(x.dtype) #uint64
>>> ```
>> 타입설정
>> - np.array(데이터, dtype=np.float32)
>>> ```Python
>>> x = np.array([1, 2, 3, 4], dtype=np.float32)
>>> print(x.dtype) #float32
>>> ```
>> 형변환
>> np.int32(ndarray)
>> 
>> 타입체크
>> ndarray.dtype
>> 
>> np.issubdtype(ndarray.dtype, np.floating)
>>> ```Python
>>> x = np.int32(x)
>>> print(x.dtype)
>>> np.issubdtype(x.dtype, np.int32) #float32
>>> ```
>> #### 다차원 ndarray
>> - 0차원 ```np.array(1)```
>>> ```Python
>>> x = np.array(1)
>>> print(x.shape) # ()
>>> print(x.ndim) # 0
>>> print(x.size) # 1
>>> ```
>> - 1차원 ```np.array([1,2])```
>>> ```Python
>>> x = np.array([1,2])
>>> print(x.shape) # (2,)
>>> print(x.ndim) # 1
>>> print(x.size) # 2
>>> ```
>> - 2차원 혹은 그 이상 ```np.array([[1,2,3],[4,5,6]])```
>>> ```Python
>>> x = np.array([[1, 2, 3],[4, 5, 6]])
>>> print(x.shape) # (2, 3)
>>> print(x.ndim) # 2
>>> print(x.size) # 6
>>> ```
>> - 차원 확인
>> 
>> ```ndarray.shape #행렬구조 ex (2, 3)```
>> 
>> ```ndarray.ndim #몇차원인지```
>> 
>> ```ndarray.size # 원소의 개수```
>> #### arange
>> range와 비슷하다.
>>> - np.arange(시작값, 끝값, 증가값)
>>> ```Python
>>> x = np.arange(10)
>>> print(x)
>>> 결과 : [0 1 2 3 4 5 6 7 8 9]
>>> 
>>> x = np.arange(10.0)
>>> print(x)
>>> 결과 : [0. 1. 2. 3. 4. 5. 6. 7. 8. 9.]
>>> 
>>> x = np.arange(1, 10, 2)
>>> print(x)
>>> 결과 : [1 3 5 7 9]
>>> 
>>> x = np.arange(1, 10, 0.5)
>>> print(x)
>>> 결과 : [1. 1.5 2. 2.5 3. 3.5 4. 4.5 5. 5.5 6. 6.5 7. 7.5 8. 8.5 9. 9.5]
>>> 
>>> x = np.arange(10, 1, -0.5)
>>> print(x)
>>> 결과 : [10. 9.5 9. 8.5 8. 7.5 7. 6.5 6.5.5 5. 4.5 4. 3.5 3. 2.5 2. 1.5]
>>> ```
>> #### linspace
>> - 균일한 간격으로 리스트 크기만큼의 리스트생성
>>> ```Python
>>> # np.linspace(시작값, 끝값, 벡터크기)
>>> x = np.linspace(1, 20, 5)
>>> print(x)
>>> 결과 : [ 1. 5.75 10.5 15.25 20. ]
>>> 
>>> # 끝값 포함여부
>>> #np.linspace(시작값, 끝값, 벡터크기, endpoint=False
>>> x = np.linspace(1, 20, 10, endpoint=False)
>>> print(x)
>>> 결과 : [ 1. 2.9 4.8 6.7 8.6 10.5 12.4 14.3 16.2 18.1]
>>> ```
>> #### reshape
>> - 데이터를 유지하면서 차원의 형태를 변경
>>> - ndarray.reshape(3, 3)
>>> ```Python
>>> x = np.arange(9).reshape(3, 3)
>>> print(x) # 2차원
>>> ```
>>> - ndarray.reshape(2, 3, 4)
>>> ```Python
>>> x = np.arange(24).reshape(2, 3, 4)
>>> print(x) # 2차원
>>> ```
>>> - ndarray.reshape(2, 2, 2, 2)
>>> ```Python
>>> x = np.arange(16).reshape(2, 2, 2, 2)
>>> print(x) # 4차원
>>> ```
>>> - np.array([[1,2],[3,4],[5,6]]).reshape(2,3)
>>> ```Python
>>> x = np.array([[1,2],[3,4],[5,6]])
>>> print(x)
>>> print(x.reshape(2,3)) # 데이터를 유지하고 형태변경
>>> ```
>>> - -1 일경우 자동으로 맞춰서 생성 ndarray.reshape(3,-1)
>>> ```Python
>>> x = np.arange(9).reshape(3, -1)
>>> print(x) #개수에 맞춰 생성
>>> ```
>> #### slicing
>>> - a[처음값:끝값:증가값]
>>> 
>>> - 1차원뿐만 아니라 다차원 슬라이싱 가능( x[1:3, 1:3], x[:3,:3,:3])
>>> ```Python
>>> # 1차원 슬라이싱
>>> x = np.arange(20)
>>> print(x[1:3])
>>> 
>>> # 2차원 슬라이싱
>>> x = np.arange(20).reshape(4,5)
>>> print(x)
>>> print(x[1:3])
>>> print(x[1:3, 1:3])
>>> 
>>> # 3차원 슬라이싱
>>> x = np.arange(30).reshape(2,5,3)
>>> print(x)
>>> print(x[:,3:5,1])
>>> ```
>> #### indexing & boolean indexing
>> - 다차원 리스트 접근 (x[1][1], x[1,1])
>> 
>> - 한번에 여러 값 인덱싱 (x[[1,1],[1,2]])
>>> ```Python
>>> # indexing
>>> print(a[1][1])
>>> print(a[1,1])
>>> print(a[[1,1],[1,2]])
>>> ```
>> - indexing에 비교, 논리연산자 사용가능 (!, &, |)
>>> ```Python
>>> # boolean indexing
>>> print(a > 3)
>>> print(a[a > 3])
>>> print(a[a == 1])
>>> print(a[~(a == 1)])
>>> print(a[(a > 3)&(a < 8)])
>>> ```
>> #### random
>> 난수가 들어가있는 다양한 형태의 데이터
>> - ```np.random.rand(5,5)```
>> 
>> - 정수난수 ```np.random.randint(1, 10)```
>> 
>> - 정수형 들어가 있는 다양한 형태의 데이터
>>> ```np.random.randint(1, 10, size=(5))```
>>> 
>>> ```np.random.randint(1, 10, size=(5,5))```
>>> 
>> - 주어진 리스트 안에 있는 숫자 뽑기
>>> ```Python
>>> np.random.choice(100, size=(3, 4))
>>> x = np.array([1, 2, 3, 4, 5, 6, 7, 8])
>>> np.random.choice(x, size=(2, 2))
>>> ```
>> #### 특이한 형태의 배열
>> - 1이 들어가있는 배열 ```np.ones([5,5])```
>> 
>> - 0이 들어가있는 배열 ```np.zeros([5,5])```
>> 
>> - 단위행렬(행렬곱을 했을때 자기자신이 나오는) ```np.eye(5)```
>> 
>> - 행렬 펼치기(행기준)
>>> ```Python
>>> ndarray.ravel()
>>> ndarray.ravel(order='C')
>>> ```
>> - 열 기준으로 펼치기
>>> ```Python
>>> ndarray.ravel(order='F')
>>> ```
>> flatten : ravel과 동일하나 복사본을 반환한다.
>> 
>> #### concatenate
>> - 배열을 연결 ```np.concatenate([x, y])```
>>> ```Python
>>> x = np.arange(1, 4)
>>> y = np.arange(4, 7)
>>> np.concatenate([x, y])
>>> 
>>> # 열을 기준으로 np.concatenate([x, y], axis=1)
>>> x = np.arange(10).reshape(2, 5)
>>> y = np.arange(10, 20).reshape(2, 5)
>>> np.concatenate([x, y])
>>> np.concatenate([x, y], axis=1)
>>> ```
>> #### split
>> - 배열을 분해 ```np.split(x, 4)
>>> ```Python
>>> x = np.arange(12)
>>> np.split(x, 4)
>>> x = np.arange(16).reshape(4, 4)
>>> np.split(x, 2)
>>> 
>>> # 열을 기준으로 np.split(x, 2, axis=1)
>>> x = np.arange(16).reshape(4, 4)
>>> np.split(x, 2, axis=1)
>>> ```
>> #### [broadcast](https://appia.tistory.com/184)
>>
>> #### 연산 및 집계함수.
>>> ```Python
>>> x.dot(y) # 행렬곱
>>> np.transpose(x) # 전치행렬
>>> np.linalg.inv(x) # 역행렬
>>> np.linalg.det(x) # 행렬식
>>> np.mean(x) # 평균
>>> np.median(x) # 중간값
>>> np.std(x) # 표준편차
>>> np.var(x) # 분산
>>> np.sum(x) # 합
>>> np.sum(데이터, axis=1) # 합, 축변경
>>> np.cumsum(x) # 누적합
>>> np.cumprod(x) # 누적곱
>>> np.min(x) # 최소값
>>> np.argmin(x) # 최소값 위치
>>> np.argmax(x) # 최대값 위치
>>> np.any(x > 4) # 하나라도 참이어야 참
>>> np.all(x > 4) # 모든 요소가 참이어야 참
>>> np.where(x > 4) # 조건에 맞는위치
>>> np.where(x > 4, x, -100) # 조건, True 일경우, False 일경우
>>> ```
>> 
> 
